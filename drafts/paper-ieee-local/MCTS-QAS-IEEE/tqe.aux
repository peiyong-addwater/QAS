\relax 
\providecommand\hyper@newdestlabel[2]{}
\providecommand\HyperFirstAtBeginDocument{\AtBeginDocument}
\HyperFirstAtBeginDocument{\ifx\hyper@anchor\@undefined
\global\let\oldcontentsline\contentsline
\gdef\contentsline#1#2#3#4{\oldcontentsline{#1}{#2}{#3}}
\global\let\oldnewlabel\newlabel
\gdef\newlabel#1#2{\newlabelxx{#1}#2}
\gdef\newlabelxx#1#2#3#4#5#6{\oldnewlabel{#1}{{#2}{#3}}}
\AtEndDocument{\ifx\hyper@anchor\@undefined
\let\contentsline\oldcontentsline
\let\newlabel\oldnewlabel
\fi}
\fi}
\global\let\hyper@last\relax 
\gdef\HyperFirstAtBeginDocument#1{#1}
\providecommand\HyField@AuxAddToFields[1]{}
\providecommand\HyField@AuxAddToCoFields[2]{}
\citation{peruzzo2014variational}
\citation{schuldpetruccione2021}
\citation{RevModPhys.92.015003}
\citation{2020optionpricing}
\citation{johnson2017qvector,Xu2021-dt}
\citation{2017hardwareefficientvqe}
\citation{physicalinspiredansatze1doi:10.1021/acs.jctc.8b01004}
\citation{Xu2021-dt}
\citation{alphafold2Jumper2021-lw}
\citation{Davies2021-xh}
\citation{DARTS_DBLP:conf/iclr/LiuSY19}
\citation{PNAS10.1007/978-3-030-01246-5_2}
\citation{AlphaXDBLP:conf/aaai/WangZJTF20}
\citation{AlphaGoDBLP:journals/nature/SilverHMGSDSAPL16}
\citation{huang2021neural}
\@writefile{toc}{\contentsline {section}{\numberline {I}Introduction}{1}{section.1}\protected@file@percent }
\citation{zhang2021differentiable}
\citation{DARTS_DBLP:conf/iclr/LiuSY19}
\citation{Shu2019-jf,Zhou2020-dg}
\citation{zhang2021neural}
\citation{kuo2021quantum}
\citation{ENASpmlr-v80-pham18a,Sutton1999-nj}
\citation{chen2021quantum}
\citation{du2020quantum}
\citation{Linghu2022-yy}
\citation{9566740mctsqas}
\citation{CMAB_RTS}
\citation{zhang2021differentiable,chen2021quantum,kuo2021quantum,zhang2021differentiable,du2020quantum,zhang2021neural}
\@writefile{toc}{\contentsline {section}{\numberline {II}Methods}{2}{section.2}\protected@file@percent }
\newlabel{methods}{{II}{2}{Methods}{section.2}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\mbox  {II-A}}Problem Formulation}{2}{subsection.2.1}\protected@file@percent }
\@writefile{lof}{\contentsline {figure}{\numberline {1}{\ignorespaces An overview of the algorithmic framework proposed in this paper. The operation pool (c) is obtained by tailoring the basic operations (a) with respect to the device topology (b). After that, we formulate the combinations of different choices of operations at different layer position in the circuit (d) as a search tree (e). In (f), we evaluate our circuit on a quantum processor or quantum simulator to get value of the loss or reward function, and according to the value of the loss/reward function we update the parameters on a classical computer, then use MCTS to search for the current best circuit. We then send the updated circuit structure together with the updated parameters to the quantum processor/simulator to obtain a new set of loss/reward values. The process depicted in (f) will repeat until a circuit that meets the stopping criteria is found. Then, as shown in (g), we will follow the usual process to optimize the parameters in the searched variational quantum circuit by classical-quantum hybrid computing..\relax }}{3}{figure.caption.1}\protected@file@percent }
\providecommand*\caption@xref[2]{\@setref\relax\@undefined{#1}}
\newlabel{fig:overview}{{1}{3}{An overview of the algorithmic framework proposed in this paper. The operation pool (c) is obtained by tailoring the basic operations (a) with respect to the device topology (b). After that, we formulate the combinations of different choices of operations at different layer position in the circuit (d) as a search tree (e). In (f), we evaluate our circuit on a quantum processor or quantum simulator to get value of the loss or reward function, and according to the value of the loss/reward function we update the parameters on a classical computer, then use MCTS to search for the current best circuit. We then send the updated circuit structure together with the updated parameters to the quantum processor/simulator to obtain a new set of loss/reward values. The process depicted in (f) will repeat until a circuit that meets the stopping criteria is found. Then, as shown in (g), we will follow the usual process to optimize the parameters in the searched variational quantum circuit by classical-quantum hybrid computing..\relax }{figure.caption.1}{}}
\newlabel{eq:U1U3U1U2}{{3}{3}{Problem Formulation}{equation.2.3}{}}
\citation{nielsen00}
\citation{CMAB_RTS}
\@writefile{lof}{\contentsline {figure}{\numberline {2}{\ignorespaces An example of the circuit corresponding to the series of unitaries applied to $\vert \varphi _{\fontencoding  {T1}\selectfont  init}\rangle $ in Eqn.\ref  {eq:U1U3U1U2}.\relax }}{4}{figure.caption.2}\protected@file@percent }
\newlabel{fig:U1U3U1U2_circ}{{2}{4}{An example of the circuit corresponding to the series of unitaries applied to $\vert \varphi _{\rm init}\rangle $ in Eqn.\ref {eq:U1U3U1U2}.\relax }{figure.caption.2}{}}
\newlabel{eq:U1U3U1U2_list}{{4}{4}{Problem Formulation}{equation.2.4}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {3}{\ignorespaces The tree representation (along the arc with blue-shaded circles) of the unitary described in Eqns. \ref  {eq:U1U3U1U2} and \ref  {eq:U1U3U1U2_list} as well as Fig.\nobreakspace  {}\ref  {fig:U1U3U1U2_circ}. The circle with $s_0$ is the root of the tree, which represents an empty circuit. Other circles with $s_i^j$ in it denote the $j^{th}$ node at the $i^{th}$ level of the tree. $i$ can also indicate the number of layers currently in the circuit at state $s_i^j$. For example, on the leftmost branch of the tree, there is a node labelled $s_2^0$, indicating that it is the $0^{th}$ node at level $2$. At $s_2^0$, the circuit would be $\mathcal  {P}_{s_2^0}=[U_0, U_0]$, which clearly only has 2 layers. We can also see that some of the possible branches along the blue-node path are pruned, leading to the size of operation pool at some node smaller than the total number of possible choices $c = \vert \mathcal  {C}\vert $.\relax }}{4}{figure.caption.3}\protected@file@percent }
\newlabel{fig:treeexample}{{3}{4}{The tree representation (along the arc with blue-shaded circles) of the unitary described in Eqns. \ref {eq:U1U3U1U2} and \ref {eq:U1U3U1U2_list} as well as Fig.~\ref {fig:U1U3U1U2_circ}. The circle with $s_0$ is the root of the tree, which represents an empty circuit. Other circles with $s_i^j$ in it denote the $j^{th}$ node at the $i^{th}$ level of the tree. $i$ can also indicate the number of layers currently in the circuit at state $s_i^j$. For example, on the leftmost branch of the tree, there is a node labelled $s_2^0$, indicating that it is the $0^{th}$ node at level $2$. At $s_2^0$, the circuit would be $\mathcal {P}_{s_2^0}=[U_0, U_0]$, which clearly only has 2 layers. We can also see that some of the possible branches along the blue-node path are pruned, leading to the size of operation pool at some node smaller than the total number of possible choices $c = \vert \mathcal {C}\vert $.\relax }{figure.caption.3}{}}
\citation{AlphaGoDBLP:journals/nature/SilverHMGSDSAPL16,AlphaGoZeroDBLP:journals/nature/SilverSSAHGHBLB17}
\citation{MCTS_for_game10.5555/3022539.3022579}
\citation{nestedmontecarlosearch}
\@writefile{toc}{\contentsline {subsection}{\numberline {\mbox  {II-B}}Monte Carlo tree search (MCTS), nested MCTS and the na\"ive assumption}{5}{subsection.2.2}\protected@file@percent }
\@writefile{lof}{\contentsline {figure}{\numberline {4}{\ignorespaces Four stages of Monte Carlo tree search. From left to right, up to down: Selection: Go down from the root node to a non fully expanded leaf node; Expansion: Expand the selected node by taking an action; Simulation: Simulate the game, which in our case is the quantum circuit, to obtain reward information {\fontencoding  {T1}\fontseries  {b}\selectfont  R}; Backpropagation: Back-propagation of the reward information along the path (arc) taken.\relax }}{5}{figure.caption.4}\protected@file@percent }
\newlabel{fig:mcts}{{4}{5}{Four stages of Monte Carlo tree search. From left to right, up to down: Selection: Go down from the root node to a non fully expande